// üìä Acumulador interno de builds morais
const pontuacaoBuild = {
  virtuoso: 0,
  profano: 0,
  anomalia: 0
};

/**
 * Registra uma escolha moral do jogador.
 * @param {string} build - 'virtuoso' | 'profano' | 'anomalia'
 */
export function registrarEscolha(build) {
  if (pontuacaoBuild[build] !== undefined) {
    pontuacaoBuild[build]++;
  } else {
    console.warn('‚ö†Ô∏è Build desconhecida registrada:', build);
  }
}

/**
 * Retorna a build dominante com base no ac√∫mulo atual.
 * @returns {string} - 'virtuoso' | 'profano' | 'anomalia'
 */
export function buildDominante() {
  const entradas = Object.entries(pontuacaoBuild);
  entradas.sort((a, b) => b[1] - a[1]);
  return entradas[0][0]; // Retorna a com maior pontua√ß√£o
}

/**
 * Retorna uma c√≥pia do hist√≥rico atual de builds.
 * @returns {{ virtuoso: number, profano: number, anomalia: number }}
 */
export function historicoBuilds() {
  return { ...pontuacaoBuild };
}

/**
 * Retorna o total de escolhas feitas no dia.
 */
export function pontuacaoTotal() {
  return Object.values(pontuacaoBuild).reduce((soma, n) => soma + n, 0);
}

/**
 * Retorna a porcentagem de cada build para visualiza√ß√µes.
 * @returns {{ virtuoso: string, profano: string, anomalia: string }}
 */
export function buildPorcentagem() {
  const total = pontuacaoTotal();
  if (total === 0) return { virtuoso: '0%', profano: '0%', anomalia: '0%' };

  return {
    virtuoso: Math.round((pontuacaoBuild.virtuoso / total) * 100) + '%',
    profano: Math.round((pontuacaoBuild.profano / total) * 100) + '%',
    anomalia: Math.round((pontuacaoBuild.anomalia / total) * 100) + '%'
  };
}

/**
 * Reseta todas as pontua√ß√µes para o pr√≥ximo ciclo.
 */
export function resetarBuild() {
  for (const chave in pontuacaoBuild) {
    pontuacaoBuild[chave] = 0;
  }
}
